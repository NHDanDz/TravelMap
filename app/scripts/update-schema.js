const { Pool } = require('pg');
require('dotenv').config({ path: '.env.local' });

const pool = new Pool({
  connectionString: process.env.POSTGRES_URL,
});

async function initCompleteSchema() {
  console.log('üîÑ Kh·ªüi t·∫°o schema ƒë·∫ßy ƒë·ªß cho database...');
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // T·∫°o c√°c enum n·∫øu ch∆∞a t·ªìn t·∫°i
    console.log('T·∫°o c√°c enum...');
    
    // Ki·ªÉm tra v√† t·∫°o enum landslide_status
    const landslideStatusExists = await enumExists(client, 'landslide_status');
    if (!landslideStatusExists) {
      await client.query(`
        CREATE TYPE landslide_status AS ENUM (
          'high_risk', 'active', 'stabilized', 'monitored', 'remediated'
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o enum landslide_status');
    } else {
      console.log('‚è≠Ô∏è Enum landslide_status ƒë√£ t·ªìn t·∫°i');
    }
    
    // Ki·ªÉm tra v√† t·∫°o enum monitor_frequency
    const monitorFrequencyExists = await enumExists(client, 'monitor_frequency');
    if (!monitorFrequencyExists) {
      await client.query(`
        CREATE TYPE monitor_frequency AS ENUM (
          'daily', 'weekly', 'biweekly', 'monthly', 'quarterly', 'custom'
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o enum monitor_frequency');
    } else {
      console.log('‚è≠Ô∏è Enum monitor_frequency ƒë√£ t·ªìn t·∫°i');
    }
    
    // Ki·ªÉm tra v√† t·∫°o enum risk_level
    const riskLevelExists = await enumExists(client, 'risk_level');
    if (!riskLevelExists) {
      await client.query(`
        CREATE TYPE risk_level AS ENUM (
          'critical', 'high', 'medium', 'low', 'negligible'
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o enum risk_level');
    } else {
      console.log('‚è≠Ô∏è Enum risk_level ƒë√£ t·ªìn t·∫°i');
    }
    
    // Ki·ªÉm tra v√† t·∫°o enum monitoring_method
    const monitoringMethodExists = await enumExists(client, 'monitoring_method');
    if (!monitoringMethodExists) {
      await client.query(`
        CREATE TYPE monitoring_method AS ENUM (
          'satellite', 'drone', 'ground', 'sensors', 'mixed'
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o enum monitoring_method');
    } else {
      console.log('‚è≠Ô∏è Enum monitoring_method ƒë√£ t·ªìn t·∫°i');
    }
    
    // Ki·ªÉm tra v√† t·∫°o enum inspection_status
    const inspectionStatusExists = await enumExists(client, 'inspection_status');
    if (!inspectionStatusExists) {
      await client.query(`
        CREATE TYPE inspection_status AS ENUM (
          'scheduled', 'in_progress', 'completed', 'cancelled', 'delayed'
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o enum inspection_status');
    } else {
      console.log('‚è≠Ô∏è Enum inspection_status ƒë√£ t·ªìn t·∫°i');
    }
    
    // Ki·ªÉm tra v√† t·∫°o enum alert_type
    const alertTypeExists = await enumExists(client, 'alert_type');
    if (!alertTypeExists) {
      await client.query(`
        CREATE TYPE alert_type AS ENUM (
          'danger', 'warning', 'info', 'success'
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o enum alert_type');
    } else {
      console.log('‚è≠Ô∏è Enum alert_type ƒë√£ t·ªìn t·∫°i');
    }
    
    // Ki·ªÉm tra v√† c√†i ƒë·∫∑t extension uuid-ossp
    try {
      await client.query(`CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`);
      console.log('‚úÖ ƒê√£ c√†i ƒë·∫∑t extension uuid-ossp');
    } catch (error) {
      console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ c√†i ƒë·∫∑t extension uuid-ossp:', error.message);
    }

    // T·∫°o b·∫£ng landslides
    console.log('Ki·ªÉm tra v√† t·∫°o b·∫£ng landslides...');
    const landslidesExists = await tableExists(client, 'landslides');
    if (!landslidesExists) {
      await client.query(`
        CREATE TABLE landslides (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          lat TEXT NOT NULL,
          lng TEXT NOT NULL,
          detected_at TIMESTAMP NOT NULL DEFAULT NOW(),
          status landslide_status NOT NULL,
          affected_area TEXT,
          potential_impact TEXT,
          last_update TIMESTAMP NOT NULL DEFAULT NOW(),
          history TEXT,
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP NOT NULL DEFAULT NOW()
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o b·∫£ng landslides');
    } else {
      console.log('‚è≠Ô∏è B·∫£ng landslides ƒë√£ t·ªìn t·∫°i');
    }

    // T·∫°o b·∫£ng monitoring_areas
    console.log('Ki·ªÉm tra v√† t·∫°o b·∫£ng monitoring_areas...');
    const monitoringAreasExists = await tableExists(client, 'monitoring_areas');
    if (!monitoringAreasExists) {
      await client.query(`
        CREATE TABLE monitoring_areas (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          description TEXT,
          north_bound TEXT NOT NULL,
          south_bound TEXT NOT NULL,
          east_bound TEXT NOT NULL,
          west_bound TEXT NOT NULL,
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          monitor_frequency monitor_frequency NOT NULL,
          last_checked TIMESTAMP NOT NULL DEFAULT NOW(),
          status TEXT NOT NULL DEFAULT 'active',
          detected_points INTEGER NOT NULL DEFAULT 0,
          risk_level risk_level NOT NULL,
          landslide_id TEXT REFERENCES landslides(id),
          auto_verify BOOLEAN DEFAULT FALSE,
          monitoring_method monitoring_method DEFAULT 'satellite',
          boundary_polygon JSONB
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o b·∫£ng monitoring_areas');
    } else {
      console.log('‚è≠Ô∏è B·∫£ng monitoring_areas ƒë√£ t·ªìn t·∫°i');
    }

    // T·∫°o b·∫£ng inspection_events
    console.log('Ki·ªÉm tra v√† t·∫°o b·∫£ng inspection_events...');
    const inspectionEventsExists = await tableExists(client, 'inspection_events');
    if (!inspectionEventsExists) {
      await client.query(`
        CREATE TABLE inspection_events (
          id TEXT PRIMARY KEY,
          monitoring_area_id TEXT NOT NULL REFERENCES monitoring_areas(id) ON DELETE CASCADE,
          name TEXT NOT NULL,
          description TEXT,
          method monitoring_method NOT NULL,
          status inspection_status NOT NULL,
          scheduled_date TIMESTAMP NOT NULL,
          start_date TIMESTAMP,
          end_date TIMESTAMP,
          findings TEXT,
          landslide_count INTEGER DEFAULT 0,
          report_url TEXT,
          metadata JSONB,
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
          created_by TEXT DEFAULT 'system'
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o b·∫£ng inspection_events');
    } else {
      console.log('‚è≠Ô∏è B·∫£ng inspection_events ƒë√£ t·ªìn t·∫°i');
    }

    // T·∫°o b·∫£ng landslide_observations
    console.log('Ki·ªÉm tra v√† t·∫°o b·∫£ng landslide_observations...');
    const landslideObservationsExists = await tableExists(client, 'landslide_observations');
    if (!landslideObservationsExists) {
      await client.query(`
        CREATE TABLE landslide_observations (
          id UUID PRIMARY KEY,
          landslide_id TEXT NOT NULL REFERENCES landslides(id) ON DELETE CASCADE,
          inspection_event_id TEXT NOT NULL REFERENCES inspection_events(id) ON DELETE CASCADE,
          observation_date TIMESTAMP NOT NULL,
          status landslide_status NOT NULL,
          movement_detected BOOLEAN DEFAULT FALSE,
          movement_rate REAL,
          affected_area_change REAL,
          stability_change REAL,
          risk_level risk_level NOT NULL,
          risk_factors JSONB,
          notes TEXT,
          media_urls JSONB,
          recommended_actions TEXT,
          actual_actions TEXT,
          observed_by TEXT,
          verified_by TEXT,
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
          UNIQUE(landslide_id, inspection_event_id)
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o b·∫£ng landslide_observations');
    } else {
      console.log('‚è≠Ô∏è B·∫£ng landslide_observations ƒë√£ t·ªìn t·∫°i');
    }

    // T·∫°o b·∫£ng notification_settings
    console.log('Ki·ªÉm tra v√† t·∫°o b·∫£ng notification_settings...');
    const notificationSettingsExists = await tableExists(client, 'notification_settings');
    if (!notificationSettingsExists) {
      await client.query(`
        CREATE TABLE notification_settings (
          id SERIAL PRIMARY KEY,
          user_id TEXT NOT NULL,
          email BOOLEAN NOT NULL DEFAULT TRUE,
          email_address TEXT,
          sms BOOLEAN NOT NULL DEFAULT FALSE,
          phone_number TEXT,
          threshold TEXT NOT NULL DEFAULT 'medium',
          update_frequency TEXT NOT NULL DEFAULT 'daily',
          weather_forecast BOOLEAN NOT NULL DEFAULT TRUE,
          auto_monitor BOOLEAN NOT NULL DEFAULT FALSE,
          monthly_report BOOLEAN NOT NULL DEFAULT TRUE,
          landslide_alerts BOOLEAN NOT NULL DEFAULT TRUE,
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP NOT NULL DEFAULT NOW()
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o b·∫£ng notification_settings');
    } else {
      console.log('‚è≠Ô∏è B·∫£ng notification_settings ƒë√£ t·ªìn t·∫°i');
    }

    // T·∫°o b·∫£ng alerts
    console.log('Ki·ªÉm tra v√† t·∫°o b·∫£ng alerts...');
    const alertsExists = await tableExists(client, 'alerts');
    if (!alertsExists) {
      await client.query(`
        CREATE TABLE alerts (
          id SERIAL PRIMARY KEY,
          type alert_type NOT NULL,
          title TEXT NOT NULL,
          description TEXT NOT NULL,
          date TIMESTAMP NOT NULL DEFAULT NOW(),
          expires_at TIMESTAMP,
          landslide_id TEXT REFERENCES landslides(id),
          monitoring_area_id TEXT REFERENCES monitoring_areas(id),
          read BOOLEAN NOT NULL DEFAULT FALSE,
          user_id TEXT NOT NULL,
          created_at TIMESTAMP NOT NULL DEFAULT NOW()
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o b·∫£ng alerts');
    } else {
      console.log('‚è≠Ô∏è B·∫£ng alerts ƒë√£ t·ªìn t·∫°i');
    }

    // T·∫°o b·∫£ng sensors
    console.log('Ki·ªÉm tra v√† t·∫°o b·∫£ng sensors...');
    const sensorsExists = await tableExists(client, 'sensors');
    if (!sensorsExists) {
      await client.query(`
        CREATE TABLE sensors (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          type TEXT NOT NULL,
          model TEXT,
          lat TEXT NOT NULL,
          lng TEXT NOT NULL,
          elevation TEXT,
          monitoring_area_id TEXT REFERENCES monitoring_areas(id) ON DELETE CASCADE,
          landslide_id TEXT REFERENCES landslides(id) ON DELETE CASCADE,
          status TEXT NOT NULL DEFAULT 'active',
          battery_level INTEGER,
          last_reading TIMESTAMP,
          reading_frequency TEXT,
          installation_date TIMESTAMP,
          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
          updated_at TIMESTAMP NOT NULL DEFAULT NOW()
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o b·∫£ng sensors');
    } else {
      console.log('‚è≠Ô∏è B·∫£ng sensors ƒë√£ t·ªìn t·∫°i');
    }

    // T·∫°o b·∫£ng sensor_data
    console.log('Ki·ªÉm tra v√† t·∫°o b·∫£ng sensor_data...');
    const sensorDataExists = await tableExists(client, 'sensor_data');
    if (!sensorDataExists) {
      await client.query(`
        CREATE TABLE sensor_data (
          id UUID PRIMARY KEY,
          sensor_id TEXT NOT NULL REFERENCES sensors(id) ON DELETE CASCADE,
          timestamp TIMESTAMP NOT NULL,
          data JSONB NOT NULL,
          status TEXT NOT NULL DEFAULT 'normal',
          anomaly_detected BOOLEAN DEFAULT FALSE,
          anomaly_type TEXT,
          created_at TIMESTAMP NOT NULL DEFAULT NOW()
        );
      `);
      console.log('‚úÖ ƒê√£ t·∫°o b·∫£ng sensor_data');
    } else {
      console.log('‚è≠Ô∏è B·∫£ng sensor_data ƒë√£ t·ªìn t·∫°i');
    }

    await client.query('COMMIT');
    console.log('‚úÖ Kh·ªüi t·∫°o schema ƒë·∫ßy ƒë·ªß th√†nh c√¥ng!');
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå L·ªói kh·ªüi t·∫°o schema:', error);
    throw error;
  } finally {
    client.release();
  }
}

// H√†m ki·ªÉm tra xem m·ªôt b·∫£ng c√≥ t·ªìn t·∫°i hay kh√¥ng
async function tableExists(client, tableName) {
  const query = `
    SELECT EXISTS (
      SELECT 1 
      FROM information_schema.tables 
      WHERE table_name = $1
    );
  `;
  
  const result = await client.query(query, [tableName]);
  return result.rows[0].exists;
}

// H√†m ki·ªÉm tra xem m·ªôt c·ªôt c√≥ t·ªìn t·∫°i trong b·∫£ng hay kh√¥ng
async function columnExists(client, tableName, columnName) {
  const query = `
    SELECT EXISTS (
      SELECT 1 
      FROM information_schema.columns 
      WHERE table_name = $1 
      AND column_name = $2
    );
  `;
  
  const result = await client.query(query, [tableName, columnName]);
  return result.rows[0].exists;
}

// H√†m ki·ªÉm tra xem m·ªôt enum c√≥ t·ªìn t·∫°i hay kh√¥ng
async function enumExists(client, enumName) {
  const query = `
    SELECT EXISTS (
      SELECT 1 
      FROM pg_type 
      WHERE typname = $1
    );
  `;
  
  const result = await client.query(query, [enumName]);
  return result.rows[0].exists;
}

// Th·ª±c hi·ªán kh·ªüi t·∫°o schema
(async () => {
  try {
    await initCompleteSchema();
    console.log('‚úÖ ƒê√£ kh·ªüi t·∫°o schema ƒë·∫ßy ƒë·ªß th√†nh c√¥ng!');
  } catch (error) {
    console.error('‚ùå L·ªói:', error);
  } finally {
    await pool.end();
  }
})();